<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kalkulator Penjadwalan Proses</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        /* === Reset & Base Styles === */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
                Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f4f7fc;
            color: #5a677d;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            padding: 16px;
        }

        /* === Container === */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 32px 24px 64px;
            display: flex;
            flex-direction: column;
            gap: 48px;
            min-height: 100vh;
        }

        /* === Header === */
        h1 {
            font-size: 52px;
            font-weight: 700;
            text-align: center;
            color: #1a2b48;
            user-select: none;
            background: linear-gradient(90deg, #3a7bd5, #3a6073);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0;
        }

        /* === Card Styling === */
        .card {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 30px -15px rgba(0, 0, 0, 0.1);
            padding: 32px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            border-left: 5px solid #3a7bd5;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px -15px rgba(58, 123, 213, 0.2);
        }

        /* === Form Elements === */
        label {
            font-weight: 600;
            color: #334155;
            margin-bottom: 8px;
            display: block;
            font-size: 16px;
        }

        input[type='number'] {
            width: 100%;
            max-width: 220px;
            padding: 12px 16px;
            font-size: 16px;
            border: 1.5px solid #d1d5db;
            border-radius: 10px;
            color: #111827;
            background-color: #f8f9fa;
            transition: all 0.3s ease;
        }

        input[type='number']:focus {
            outline: none;
            border-color: #3a7bd5;
            box-shadow: 0 0 0 4px rgba(58, 123, 213, 0.2);
            background-color: #fff;
        }

        /* === Button Styling === */
        button {
            cursor: pointer;
            background: linear-gradient(90deg, #3a7bd5, #3a6073);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 24px;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            align-self: flex-start;
            min-width: 200px;
            box-shadow: 0 4px 15px rgba(58, 123, 213, 0.3);
            letter-spacing: 0.5px;
        }

        button:hover,
        button:focus {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(58, 123, 213, 0.4);
            outline: none;
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(58, 123, 213, 0.3);
        }

        /* === Process Input Layout === */
        .process-input {
            display: flex;
            flex-wrap: wrap;
            gap: 20px 28px;
            align-items: flex-end;
            /* Aligns items to the bottom */
            padding-bottom: 24px;
            border-bottom: 1px solid #e5e7eb;
        }

        .process-input:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .process-input h3 {
            flex-basis: 100%;
            font-weight: 700;
            font-size: 22px;
            color: #3a7bd5;
            margin: 0 0 8px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #f0f0f0;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        /* === Results Section === */
        .results-card h2 {
            color: #1a2b48;
            font-weight: 700;
            font-size: 36px;
            border-bottom: 3px solid #3a7bd5;
            padding-bottom: 12px;
            margin: 0 0 28px 0;
            user-select: none;
        }

        .results-card h3 {
            font-size: 24px;
            font-weight: 600;
            margin-top: 32px;
            margin-bottom: 16px;
            color: #3a6073;
            user-select: none;
        }

        /* === Table Styling === */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 16px;
            color: #374151;
            box-shadow: 0 5px 25px -10px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            /* Important for border-radius */
        }

        thead th {
            text-align: left;
            padding: 16px 20px;
            background: linear-gradient(90deg, #3a7bd5, #3a6073);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            user-select: none;
        }

        tbody tr {
            background: #ffffff;
            border-bottom: 1px solid #f0f2f5;
            transition: background-color 0.25s ease, transform 0.25s ease;
        }

        tbody tr:last-child {
            border-bottom: none;
        }

        tbody tr:hover {
            background-color: #eff6ff;
            transform: scale(1.02);
            /* Slight zoom on hover */
        }

        tbody td {
            padding: 16px 20px;
            user-select: text;
        }

        /* === Responsive Adjustments === */
        @media (max-width: 768px) {
            h1 {
                font-size: 40px;
            }

            .process-input {
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }

            input[type='number'] {
                max-width: 100%;
            }

            .card {
                padding: 24px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px 12px 32px;
            }

            h1 {
                font-size: 32px;
            }

            button {
                width: 100%;
            }

            .results-card h2 {
                font-size: 28px;
            }

            .results-card h3 {
                font-size: 20px;
            }
        }
    </style>
</head>

<body>
    <main class="container" role="main">
        <h1>Kalkulator Penjadwalan Proses</h1>

        <section aria-label="Formulir Input Proses" class="card">
            <div class="input-group">
                <label for="numProcesses">Jumlah Proses:</label>
                <input type="number" id="numProcesses" min="1" value="4" aria-describedby="numProcessesDesc" />
                <div id="numProcessesDesc" class="sr-only">Masukkan total jumlah proses yang akan dijadwalkan</div>
            </div>

            <button type="button" onclick="generateInputFields()" aria-label="Buat bidang input untuk setiap proses">
                Buat Input Proses
            </button>

            <form id="processInputs" aria-live="polite" aria-relevant="additions">
            </form>

            <div class="input-group">
                <label for="quantum">Quantum untuk Round Robin:</label>
                <input type="number" id="quantum" min="1" placeholder="cth: 2" aria-describedby="quantumDesc" />
                <div id="quantumDesc" class="sr-only">Masukkan waktu quantum untuk penjadwalan Round Robin</div>
            </div>

            <button type="button" onclick="calculateScheduling()" aria-label="Hitung hasil penjadwalan">
                Hitung Penjadwalan
            </button>
        </section>

        <section aria-label="Hasil Penjadwalan" id="results-section" class="card results-card" style="display: none;">
            <h2>Hasil Perhitungan</h2>
            <div id="results"></div>
        </section>
    </main>

    <script>
        // Panggil fungsi ini saat halaman dimuat untuk membuat input awal
        document.addEventListener('DOMContentLoaded', function () {
            generateInputFields();
        });

        function generateInputFields() {
            const numProcesses = parseInt(document.getElementById('numProcesses').value) || 1;
            const processInputs = document.getElementById('processInputs');
            processInputs.innerHTML = '';

            for (let i = 0; i < numProcesses; i++) {
                const processBlock = document.createElement('div');
                processBlock.className = 'process-input';

                const heading = document.createElement('h3');
                heading.textContent = `Proses P${i + 1}`;
                processBlock.appendChild(heading);

                // Input Waktu Kedatangan (Arrival Time)
                const arrivalGroup = document.createElement('div');
                arrivalGroup.className = 'input-group';
                const labelArrival = document.createElement('label');
                labelArrival.setAttribute('for', 'arrivalTime' + i);
                labelArrival.textContent = 'Waktu Kedatangan:';
                arrivalGroup.appendChild(labelArrival);

                const inputArrival = document.createElement('input');
                inputArrival.type = 'number';
                inputArrival.id = 'arrivalTime' + i;
                inputArrival.required = true;
                inputArrival.min = '0';
                inputArrival.placeholder = 'cth: 0';
                arrivalGroup.appendChild(inputArrival);
                processBlock.appendChild(arrivalGroup);

                // Input Waktu Proses (Burst Time)
                const burstGroup = document.createElement('div');
                burstGroup.className = 'input-group';
                const labelBurst = document.createElement('label');
                labelBurst.setAttribute('for', 'burstTime' + i);
                labelBurst.textContent = 'Waktu Proses:';
                burstGroup.appendChild(labelBurst);

                const inputBurst = document.createElement('input');
                inputBurst.type = 'number';
                inputBurst.id = 'burstTime' + i;
                inputBurst.required = true;
                inputBurst.min = '1';
                inputBurst.placeholder = 'cth: 8';
                burstGroup.appendChild(inputBurst);
                processBlock.appendChild(burstGroup);

                processInputs.appendChild(processBlock);
            }
        }

        function calculateScheduling() {
            const numProcesses = parseInt(document.getElementById('numProcesses').value);
            const quantumInput = document.getElementById('quantum');
            const quantum = parseInt(quantumInput.value);
            const resultsDiv = document.getElementById('results');
            const resultsSection = document.getElementById('results-section');
            resultsDiv.innerHTML = '';

            const processes = [];

            for (let i = 0; i < numProcesses; i++) {
                const arrivalTime = parseInt(document.getElementById(`arrivalTime${i}`).value);
                const burstTime = parseInt(document.getElementById(`burstTime${i}`).value);

                if (isNaN(arrivalTime) || arrivalTime < 0) {
                    alert(`Masukkan Waktu Kedatangan yang valid (>= 0) untuk Proses P${i + 1}.`);
                    document.getElementById(`arrivalTime${i}`).focus();
                    return;
                }
                if (isNaN(burstTime) || burstTime < 1) {
                    alert(`Masukkan Waktu Proses yang valid (>= 1) untuk Proses P${i + 1}.`);
                    document.getElementById(`burstTime${i}`).focus();
                    return;
                }

                processes.push({
                    name: `P${i + 1}`,
                    arrivalTime,
                    burstTime
                });
            }

            if (isNaN(quantum) || quantum < 1) {
                if (processes.some(p => p.burstTime > 0)) { // Cek jika ada proses yang perlu Round Robin
                    alert('Masukkan nilai Quantum yang valid (> 0) untuk Round Robin.');
                    quantumInput.focus();
                    return;
                }
            }


            const fifoResults = fifoScheduling(JSON.parse(JSON.stringify(processes)));
            const sjfResults = sjfScheduling(JSON.parse(JSON.stringify(processes)));
            const srtfResults = srtfScheduling(JSON.parse(JSON.stringify(processes)));

            displayResults(fifoResults, "Penjadwalan FIFO (First-In, First-Out)");
            displayResults(sjfResults, "Penjadwalan SJF (Shortest Job First) Non-Preemptive");
            displayResults(srtfResults, "Penjadwalan SRTF (Shortest Remaining Time First) Preemptive");

            if (!isNaN(quantum) && quantum > 0) {
                const rrResults = roundRobinScheduling(JSON.parse(JSON.stringify(processes)), quantum);
                displayResults(rrResults, `Penjadwalan Round Robin (Quantum = ${quantum})`);
            }

            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });

        }

        function displayResults(results, title) {
            const resultsDiv = document.getElementById('results');
            let totalTurnaroundTime = 0;
            let totalWaitingTime = 0;

            let html = `<h3>${title}</h3>`;
            html += `
        <table>
            <thead>
                <tr>
                    <th>Proses</th>
                    <th>Waktu Kedatangan</th>
                    <th>Waktu Proses</th>
                    <th>Waktu Selesai</th>
                    <th>Turnaround Time</th>
                    <th>Waiting Time</th>
                </tr>
            </thead>
            <tbody>
        `;
            results.forEach(p => {
                totalTurnaroundTime += p.turnaroundTime;
                totalWaitingTime += p.waitingTime;
                html += `
            <tr>
                <td><b>${p.name}</b></td>
                <td>${p.arrivalTime}</td>
                <td>${p.burstTimeOriginal}</td>
                <td>${p.completionTime !== undefined ? p.completionTime : ''}</td>
                <td>${p.turnaroundTime !== undefined ? p.turnaroundTime : ''}</td>
                <td>${p.waitingTime !== undefined ? p.waitingTime : ''}</td>
            </tr>
        `;
            });

            const avgTurnaroundTime = totalTurnaroundTime / results.length;
            const avgWaitingTime = totalWaitingTime / results.length;

            html += `
                </tbody>
                <tfoot>
                    <tr style="background-color: #f0f2f5; font-weight: 600;">
                        <td colspan="4" style="text-align: right;">Rata-rata:</td>
                        <td>${avgTurnaroundTime.toFixed(2)}</td>
                        <td>${avgWaitingTime.toFixed(2)}</td>
                    </tr>
                </tfoot>
            </table>`;
            resultsDiv.innerHTML += html;
        }

        // --- ALGORITHMS (LOGIC UNCHANGED, BUT ADDED WAITING TIME & ORIGINAL BURST TIME) ---

        function fifoScheduling(processes) {
            let currentTime = 0;
            processes.sort((a, b) => a.arrivalTime - b.arrivalTime);
            processes.forEach(p => {
                p.burstTimeOriginal = p.burstTime;
                if (currentTime < p.arrivalTime) {
                    currentTime = p.arrivalTime;
                }
                const waitingTime = currentTime - p.arrivalTime;
                currentTime += p.burstTime;
                p.completionTime = currentTime;
                p.turnaroundTime = p.completionTime - p.arrivalTime;
                p.waitingTime = waitingTime;
            });
            return processes;
        }

        function sjfScheduling(processes) {
            let currentTime = 0;
            const n = processes.length;
            const completed = new Array(n).fill(false);
            let completedCount = 0;

            processes.forEach(p => p.burstTimeOriginal = p.burstTime);

            while (completedCount < n) {
                let idx = -1;
                let minBurst = Infinity;

                for (let i = 0; i < n; i++) {
                    if (!completed[i] && processes[i].arrivalTime <= currentTime && processes[i].burstTime < minBurst) {
                        minBurst = processes[i].burstTime;
                        idx = i;
                    }
                }

                if (idx !== -1) {
                    const p = processes[idx];
                    const waitingTime = currentTime - p.arrivalTime;
                    currentTime += p.burstTime;
                    p.completionTime = currentTime;
                    p.turnaroundTime = p.completionTime - p.arrivalTime;
                    p.waitingTime = waitingTime;
                    completed[idx] = true;
                    completedCount++;
                } else {
                    currentTime++;
                }
            }
            return processes;
        }

        function srtfScheduling(processes) {
            let currentTime = 0;
            const n = processes.length;
            let completedCount = 0;
            const remainingTime = processes.map(p => p.burstTime);
            processes.forEach(p => p.burstTimeOriginal = p.burstTime);

            while (completedCount < n) {
                let idx = -1;
                let minRemTime = Infinity;

                for (let i = 0; i < n; i++) {
                    if (processes[i].arrivalTime <= currentTime && remainingTime[i] > 0 && remainingTime[i] < minRemTime) {
                        minRemTime = remainingTime[i];
                        idx = i;
                    }
                }

                if (idx !== -1) {
                    remainingTime[idx]--;
                    currentTime++;
                    if (remainingTime[idx] === 0) {
                        completedCount++;
                        const p = processes[idx];
                        p.completionTime = currentTime;
                        p.turnaroundTime = p.completionTime - p.arrivalTime;
                        p.waitingTime = p.turnaroundTime - p.burstTimeOriginal;
                    }
                } else {
                    currentTime++;
                }
            }
            return processes;
        }

        function roundRobinScheduling(processes, quantum) {
            let currentTime = 0;
            const n = processes.length;
            const remainingTime = processes.map(p => p.burstTime);
            processes.forEach(p => p.burstTimeOriginal = p.burstTime);

            const queue = [];
            let completedCount = 0;
            let currentQueueIndex = 0;

            // Sort processes by arrival time to handle initial queueing
            const sortedProcesses = [...processes].map((p, i) => ({ ...p, originalIndex: i })).sort((a, b) => a.arrivalTime - b.arrivalTime);

            while (completedCount < n) {
                // Add processes that have arrived to the queue
                for (let i = 0; i < sortedProcesses.length; i++) {
                    if (sortedProcesses[i].arrivalTime <= currentTime && !queue.includes(sortedProcesses[i].originalIndex) && remainingTime[sortedProcesses[i].originalIndex] > 0) {
                        queue.push(sortedProcesses[i].originalIndex);
                    }
                }

                if (queue.length === 0) {
                    currentTime++;
                    continue;
                }

                const idx = queue.shift(); // Get process from the front of the queue
                const execTime = Math.min(quantum, remainingTime[idx]);

                currentTime += execTime;
                remainingTime[idx] -= execTime;

                // Re-check for new arrivals during the execution slice
                for (let i = 0; i < sortedProcesses.length; i++) {
                    if (sortedProcesses[i].arrivalTime <= currentTime && !queue.includes(sortedProcesses[i].originalIndex) && remainingTime[sortedProcesses[i].originalIndex] > 0) {
                        // To maintain order, insert based on arrival time
                        if (!queue.includes(sortedProcesses[i].originalIndex)) {
                            queue.push(sortedProcesses[i].originalIndex);
                        }
                    }
                }

                if (remainingTime[idx] === 0) {
                    completedCount++;
                    const p = processes[idx];
                    p.completionTime = currentTime;
                    p.turnaroundTime = p.completionTime - p.arrivalTime;
                    p.waitingTime = p.turnaroundTime - p.burstTimeOriginal;
                } else {
                    queue.push(idx); // Add it back to the end of the queue
                }
            }

            return processes;
        }

    </script>
</body>

</html>